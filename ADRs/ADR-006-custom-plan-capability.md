# ADR-006: Custom Plan Capability for Chronological and Thematic Reading

**Status**: Proposed
**Date**: 2025-12-28
**Decision Makers**: Development Team
**Supersedes**: N/A
**Related to**: ADR-001 (Bible Study Planner Architecture)

---

## Context

The Bible study planner currently supports only canonical (book order) reading plans, where books are read in their traditional order from Genesis to Revelation. However, many users desire alternative reading approaches:

### User Needs

1. **Chronological Reading**: Read the Bible in the order events occurred historically
   - Example: Job before Genesis 12, Chronicles parallel with Kings, etc.
   - Helps understand Biblical narrative in historical sequence
   - Popular plans: One Year Chronological Bible, Blue Letter Bible Chronological

2. **Thematic Reading**: Study Scripture organized by topics or themes
   - Example: "Wisdom Literature in 60 Days", "Paul's Letters in Theological Order"
   - Enables focused topical study
   - Supports sermon series, group studies, or personal deep-dives

3. **Custom Reading**: User-defined reading orders for specific purposes
   - Example: "Gospels + Epistles" for new believers
   - Example: "Prophets Contextualized" reading major/minor prophets with historical books
   - Example: "Psalms & Proverbs Daily" mixed with other reading

### Current Limitations

**Canonical Plan Only**:
```
Genesis 1-3 â†’ Genesis 4-6 â†’ ... â†’ Revelation 20-22
```

**Cannot Support**:
- Reading Job before Abraham's story
- Parallel reading of 1-2 Chronicles with 1-2 Kings
- Thematic groupings (all prophecies about Messiah)
- Custom devotional plans
- Well-known published plans (e.g., M'Cheyne, ESV Study Bible plans)

### Problem Statement

Users want to:
1. Follow popular chronological Bible reading plans
2. Create thematic studies for specific topics
3. Define custom reading orders for group studies or personal preferences
4. Import well-known published plans (M'Cheyne, ESV, etc.)
5. Share custom plans with their community

The current architecture supports this via the Strategy Pattern, but no implementation exists for custom plan definitions.

### Constraints

- Must integrate with existing Strategy Pattern architecture
- Should not break existing canonical plan functionality
- Must support the same metadata (verse counts, reading time, etc.)
- Plan definitions should be user-friendly (not requiring code changes)
- Must handle complex scenarios (parallel readings, thematic groupings)

---

## Decision

We will implement a **Custom Plan Capability** that allows users to define reading plans via JSON configuration files. This will support both chronological and thematic reading plans through a flexible, data-driven approach.

### Core Design Decisions

#### 1. Plan Definition Format: JSON Schema

**Decision**: Use JSON files to define custom reading plans with a structured schema

**Rationale**:
- Human-readable and editable
- Easy to validate and parse
- Supports version control and sharing
- No programming knowledge required
- Can be generated by tools or websites

#### 2. Plan Storage Location

**Decision**: Store plan definitions in `data/reading_plans/` directory

**Structure**:
```
data/
  â””â”€â”€ reading_plans/
      â”œâ”€â”€ canonical.json         # Built-in canonical plan definition
      â”œâ”€â”€ chronological.json     # Built-in chronological plan
      â”œâ”€â”€ mcheyne.json          # Robert M'Cheyne plan
      â”œâ”€â”€ esv-study.json        # ESV Study Bible plan
      â””â”€â”€ custom/               # User custom plans
          â”œâ”€â”€ gospels-focus.json
          â””â”€â”€ wisdom-60-days.json
```

#### 3. Implementation Strategy: CustomPlan Class

**Decision**: Create `CustomPlan` strategy class that loads and executes plan definitions

**Benefits**:
- Leverages existing Strategy Pattern
- Separates plan definition from execution logic
- Reuses existing chapter distribution and statistics code
- Enables plan validation and error checking

#### 4. CLI Integration

**Decision**: Add `--plan` option to specify which plan to use

**Usage**:
```bash
# Use built-in chronological plan
bible-study-planner generate --plan chronological

# Use custom plan file
bible-study-planner generate --plan data/reading_plans/custom/my-plan.json

# Default to canonical (backward compatible)
bible-study-planner generate
```

---

## Plan Definition Schema

### Basic Schema Structure

```json
{
  "plan_meta": {
    "name": "Plan Name",
    "plan_id": "unique-identifier",
    "description": "Description of the reading plan",
    "version": "1.0",
    "author": "Author name",
    "strategy": "chronological | thematic | custom",
    "scope": "complete | old_testament | new_testament",
    "default_days": 365,
    "tags": ["chronological", "historical"]
  },
  "reading_order": [
    {
      "day": 1,
      "segments": [
        {
          "book": "Genesis",
          "chapters": "1-3"
        }
      ]
    },
    {
      "day": 2,
      "segments": [
        {
          "book": "Job",
          "chapters": "1-2"
        }
      ]
    }
  ]
}
```

### Field Definitions

**plan_meta**:
- `name` (string, required): Human-readable plan name
- `plan_id` (string, required): Unique identifier for the plan
- `description` (string, optional): Description of the plan's purpose
- `version` (string, optional): Plan version for tracking updates
- `author` (string, optional): Plan creator
- `strategy` (string, required): Plan type (chronological, thematic, custom)
- `scope` (string, required): Bible scope covered
- `default_days` (integer, optional): Suggested number of days
- `tags` (array, optional): Tags for categorization

**reading_order**:
- Array of daily reading assignments
- Each entry specifies one or more reading segments for that day

**segment**:
- `book` (string, required): Book name (must match data/books.json)
- `chapters` (string, required): Chapter range (e.g., "1", "1-3", "1,3,5")

### Advanced Schema Features

#### Multiple Segments Per Day

```json
{
  "day": 15,
  "segments": [
    {
      "book": "Genesis",
      "chapters": "37-40"
    },
    {
      "book": "Psalms",
      "chapters": "15"
    }
  ]
}
```

#### Chapter Lists (Non-Contiguous)

```json
{
  "book": "Psalms",
  "chapters": "1,15,23,51,103"
}
```

#### Parallel Readings

```json
{
  "day": 42,
  "note": "Read Kings and Chronicles in parallel",
  "segments": [
    {
      "book": "1 Kings",
      "chapters": "1-2"
    },
    {
      "book": "1 Chronicles",
      "chapters": "1-2"
    }
  ]
}
```

#### Thematic Grouping Metadata

```json
{
  "day": 100,
  "theme": "Messianic Prophecies",
  "segments": [
    {
      "book": "Isaiah",
      "chapters": "7,9,53"
    },
    {
      "book": "Micah",
      "chapters": "5"
    }
  ]
}
```

---

## Example Plan Definitions

### Example 1: Chronological Bible Plan (Simplified)

```json
{
  "plan_meta": {
    "name": "Chronological Bible Reading Plan",
    "plan_id": "chronological-365",
    "description": "Read the Bible in the order events occurred",
    "version": "1.0",
    "author": "Bible Study Planner",
    "strategy": "chronological",
    "scope": "complete",
    "default_days": 365,
    "tags": ["chronological", "historical", "complete-bible"]
  },
  "reading_order": [
    {
      "day": 1,
      "note": "Creation and Fall",
      "segments": [
        {
          "book": "Genesis",
          "chapters": "1-3"
        }
      ]
    },
    {
      "day": 2,
      "note": "Job's story (likely pre-Abrahamic)",
      "segments": [
        {
          "book": "Job",
          "chapters": "1-5"
        }
      ]
    },
    {
      "day": 3,
      "segments": [
        {
          "book": "Job",
          "chapters": "6-10"
        }
      ]
    },
    {
      "day": 50,
      "note": "Parallel reading: Kings and Chronicles",
      "segments": [
        {
          "book": "1 Kings",
          "chapters": "12"
        },
        {
          "book": "2 Chronicles",
          "chapters": "10-11"
        }
      ]
    }
  ]
}
```

### Example 2: Thematic Plan - Wisdom Literature

```json
{
  "plan_meta": {
    "name": "Wisdom Literature in 60 Days",
    "plan_id": "wisdom-60",
    "description": "Deep dive into Job, Psalms, Proverbs, Ecclesiastes, and Song of Solomon",
    "version": "1.0",
    "strategy": "thematic",
    "scope": "old_testament",
    "default_days": 60,
    "tags": ["wisdom", "poetry", "thematic"]
  },
  "reading_order": [
    {
      "day": 1,
      "theme": "Introduction to Suffering",
      "segments": [
        {
          "book": "Job",
          "chapters": "1-2"
        }
      ]
    },
    {
      "day": 15,
      "theme": "Daily Wisdom",
      "segments": [
        {
          "book": "Proverbs",
          "chapters": "1"
        },
        {
          "book": "Psalms",
          "chapters": "1,19"
        }
      ]
    },
    {
      "day": 45,
      "theme": "Life's Meaning",
      "segments": [
        {
          "book": "Ecclesiastes",
          "chapters": "1-3"
        }
      ]
    }
  ]
}
```

### Example 3: Custom Plan - Gospel Study

```json
{
  "plan_meta": {
    "name": "Four Gospels in Harmony",
    "plan_id": "gospels-harmony-90",
    "description": "Read all four Gospels with harmonized parallel passages",
    "version": "1.0",
    "strategy": "custom",
    "scope": "new_testament",
    "default_days": 90,
    "tags": ["gospels", "harmonized", "new-testament"]
  },
  "reading_order": [
    {
      "day": 1,
      "theme": "Birth Narratives",
      "segments": [
        {
          "book": "Matthew",
          "chapters": "1-2"
        },
        {
          "book": "Luke",
          "chapters": "1-2"
        }
      ]
    },
    {
      "day": 2,
      "theme": "Early Ministry",
      "segments": [
        {
          "book": "Mark",
          "chapters": "1"
        },
        {
          "book": "John",
          "chapters": "1"
        }
      ]
    }
  ]
}
```

---

## Component Architecture

### CustomPlan Strategy Class

**Location**: `bible_study_planner/plans/custom.py`

```python
"""Custom reading plan strategy."""

from datetime import date
from pathlib import Path
from typing import List, Dict, Any
import json

from ..bible.data_manager import BibleScope
from ..models.book import Book
from ..models.reading_segment import ReadingSegment
from ..models.study_day import StudyDay
from .base import ReadingPlanStrategy


class CustomPlan(ReadingPlanStrategy):
    """
    Custom reading plan strategy.

    Loads reading plans from JSON definitions, supporting:
    - Chronological plans (historical order)
    - Thematic plans (topic-based grouping)
    - Custom user-defined plans
    """

    def __init__(self, bible_data, plan_file: Path):
        """Initialize custom plan with plan definition file.

        Args:
            bible_data: Bible data manager instance
            plan_file: Path to plan definition JSON file
        """
        super().__init__(bible_data)
        self.plan_file = plan_file
        self.plan_definition = self._load_plan_definition()
        self._validate_plan()

    def _load_plan_definition(self) -> Dict[str, Any]:
        """Load plan definition from JSON file.

        Returns:
            Dictionary containing plan definition

        Raises:
            FileNotFoundError: If plan file doesn't exist
            json.JSONDecodeError: If plan file is invalid JSON
        """
        if not self.plan_file.exists():
            raise FileNotFoundError(f"Plan file not found: {self.plan_file}")

        with open(self.plan_file, 'r', encoding='utf-8') as f:
            return json.load(f)

    def _validate_plan(self) -> None:
        """Validate plan definition structure and content.

        Raises:
            ValueError: If plan definition is invalid
        """
        # Check required top-level keys
        if "plan_meta" not in self.plan_definition:
            raise ValueError("Plan definition missing 'plan_meta' section")
        if "reading_order" not in self.plan_definition:
            raise ValueError("Plan definition missing 'reading_order' section")

        meta = self.plan_definition["plan_meta"]

        # Check required metadata fields
        required_meta = ["name", "plan_id", "strategy", "scope"]
        for field in required_meta:
            if field not in meta:
                raise ValueError(f"Plan metadata missing required field: {field}")

        # Validate scope
        valid_scopes = ["complete", "old_testament", "new_testament"]
        if meta["scope"] not in valid_scopes:
            raise ValueError(f"Invalid scope: {meta['scope']}. Must be one of {valid_scopes}")

        # Validate strategy
        valid_strategies = ["chronological", "thematic", "custom"]
        if meta["strategy"] not in valid_strategies:
            raise ValueError(f"Invalid strategy: {meta['strategy']}. Must be one of {valid_strategies}")

        # Validate reading order
        reading_order = self.plan_definition["reading_order"]
        if not isinstance(reading_order, list) or len(reading_order) == 0:
            raise ValueError("reading_order must be a non-empty array")

        # Validate each day's definition
        for i, day_def in enumerate(reading_order):
            if "segments" not in day_def:
                raise ValueError(f"Day {i+1} missing 'segments' field")
            if not isinstance(day_def["segments"], list) or len(day_def["segments"]) == 0:
                raise ValueError(f"Day {i+1} must have at least one segment")

            for j, segment in enumerate(day_def["segments"]):
                if "book" not in segment:
                    raise ValueError(f"Day {i+1}, segment {j+1} missing 'book' field")
                if "chapters" not in segment:
                    raise ValueError(f"Day {i+1}, segment {j+1} missing 'chapters' field")

    def generate_schedule(
        self, start_date: date, days: int, scope: BibleScope
    ) -> List[StudyDay]:
        """Generate reading schedule from plan definition.

        Args:
            start_date: Starting date for the reading plan
            days: Number of days in the plan (may override plan definition)
            scope: Bible scope (must match plan definition scope)

        Returns:
            List of StudyDay objects
        """
        # Verify scope matches plan definition
        plan_scope_str = self.plan_definition["plan_meta"]["scope"]
        plan_scope = self._scope_str_to_enum(plan_scope_str)
        if scope != plan_scope:
            raise ValueError(
                f"Requested scope '{scope}' does not match plan scope '{plan_scope}'"
            )

        reading_order = self.plan_definition["reading_order"]

        # Determine actual number of days (use plan definition or user override)
        actual_days = len(reading_order)
        if days and days != actual_days:
            # User specified different number of days
            # For custom plans, we must use the defined days
            print(f"Warning: Plan defines {actual_days} days, ignoring --days {days}")

        # Generate dates
        dates = self._generate_dates(start_date, actual_days)

        # Create StudyDay objects from plan definition
        schedule = []
        for day_num, (day_date, day_def) in enumerate(zip(dates, reading_order), start=1):
            # Parse segments
            segments = self._parse_segments(day_def["segments"])

            # Create StudyDay
            study_day = StudyDay(
                date=day_date,
                day_number=day_num,
                reading_segments=segments,
                total_days=actual_days,
            )

            # Add optional metadata
            if "theme" in day_def:
                study_day.theme = day_def["theme"]
            if "note" in day_def:
                study_day.note = day_def["note"]

            schedule.append(study_day)

        return schedule

    def _parse_segments(self, segment_defs: List[Dict[str, str]]) -> List[ReadingSegment]:
        """Parse segment definitions into ReadingSegment objects.

        Args:
            segment_defs: List of segment definitions from plan

        Returns:
            List of ReadingSegment objects
        """
        segments = []

        for seg_def in segment_defs:
            book_name = seg_def["book"]
            chapters_str = seg_def["chapters"]

            # Get book object
            book = self.bible_data.get_book_by_name(book_name)
            if not book:
                raise ValueError(f"Unknown book: {book_name}")

            # Parse chapter specification
            chapter_ranges = self._parse_chapter_spec(chapters_str, book)

            # Create ReadingSegment for each range
            for start_ch, end_ch in chapter_ranges:
                verse_count = book.get_verses_in_range(start_ch, end_ch)
                word_count = book.get_word_count_in_range(start_ch, end_ch)
                estimated_minutes = self.bible_data.calculate_reading_time(
                    book.name, start_ch, end_ch
                )

                segment = ReadingSegment(
                    book=book,
                    start_chapter=start_ch,
                    end_chapter=end_ch,
                    verse_count=verse_count,
                    word_count=word_count,
                    estimated_minutes=estimated_minutes,
                )
                segments.append(segment)

        return segments

    def _parse_chapter_spec(self, chapters_str: str, book: Book) -> List[tuple[int, int]]:
        """Parse chapter specification string.

        Supports:
        - Single chapter: "5" â†’ [(5, 5)]
        - Range: "5-8" â†’ [(5, 8)]
        - List: "1,3,5" â†’ [(1, 1), (3, 3), (5, 5)]
        - Mixed: "1-3,5,7-9" â†’ [(1, 3), (5, 5), (7, 9)]

        Args:
            chapters_str: Chapter specification
            book: Book object for validation

        Returns:
            List of (start_chapter, end_chapter) tuples
        """
        ranges = []

        # Split by comma for multiple ranges
        parts = chapters_str.split(',')

        for part in parts:
            part = part.strip()

            if '-' in part:
                # Range specification
                start_str, end_str = part.split('-', 1)
                start = int(start_str.strip())
                end = int(end_str.strip())

                # Validate chapter numbers
                if start < 1 or end > book.chapters or start > end:
                    raise ValueError(
                        f"Invalid chapter range {start}-{end} for {book.name} "
                        f"(has {book.chapters} chapters)"
                    )
                ranges.append((start, end))
            else:
                # Single chapter
                chapter = int(part)
                if chapter < 1 or chapter > book.chapters:
                    raise ValueError(
                        f"Invalid chapter {chapter} for {book.name} "
                        f"(has {book.chapters} chapters)"
                    )
                ranges.append((chapter, chapter))

        return ranges

    def _scope_str_to_enum(self, scope_str: str) -> BibleScope:
        """Convert scope string to BibleScope enum.

        Args:
            scope_str: Scope string from plan definition

        Returns:
            BibleScope enum value
        """
        mapping = {
            "complete": BibleScope.COMPLETE,
            "old_testament": BibleScope.OLD_TESTAMENT,
            "new_testament": BibleScope.NEW_TESTAMENT,
        }
        return mapping[scope_str]

    def get_plan_metadata(self) -> Dict[str, Any]:
        """Get plan metadata for display and indexing.

        Returns:
            Plan metadata dictionary
        """
        return self.plan_definition["plan_meta"]
```

### Plan Manager Utility

**Location**: `bible_study_planner/plans/plan_manager.py`

```python
"""Plan manager for discovering and loading reading plans."""

from pathlib import Path
from typing import List, Dict, Any, Optional
import json


class PlanManager:
    """Manages reading plan discovery and loading."""

    def __init__(self, plans_directory: Path):
        """Initialize plan manager.

        Args:
            plans_directory: Directory containing plan JSON files
        """
        self.plans_directory = plans_directory

    def list_available_plans(self) -> List[Dict[str, Any]]:
        """List all available reading plans.

        Returns:
            List of plan metadata dictionaries
        """
        plans = []

        # Search for JSON files in plans directory
        for plan_file in self.plans_directory.glob("**/*.json"):
            try:
                with open(plan_file, 'r', encoding='utf-8') as f:
                    plan_def = json.load(f)
                    if "plan_meta" in plan_def:
                        meta = plan_def["plan_meta"].copy()
                        meta["file_path"] = str(plan_file)
                        plans.append(meta)
            except (json.JSONDecodeError, IOError):
                # Skip invalid files
                continue

        return plans

    def get_plan_file(self, plan_identifier: str) -> Optional[Path]:
        """Get plan file path by plan ID or name.

        Args:
            plan_identifier: Plan ID, name, or file path

        Returns:
            Path to plan file, or None if not found
        """
        # Check if it's already a file path
        plan_path = Path(plan_identifier)
        if plan_path.exists() and plan_path.suffix == '.json':
            return plan_path

        # Search by plan_id or name
        for plan_file in self.plans_directory.glob("**/*.json"):
            try:
                with open(plan_file, 'r', encoding='utf-8') as f:
                    plan_def = json.load(f)
                    if "plan_meta" in plan_def:
                        meta = plan_def["plan_meta"]
                        if (meta.get("plan_id") == plan_identifier or
                            meta.get("name") == plan_identifier or
                            plan_file.stem == plan_identifier):
                            return plan_file
            except (json.JSONDecodeError, IOError):
                continue

        return None

    def validate_plan_file(self, plan_file: Path) -> tuple[bool, Optional[str]]:
        """Validate a plan file.

        Args:
            plan_file: Path to plan file

        Returns:
            Tuple of (is_valid, error_message)
        """
        try:
            with open(plan_file, 'r', encoding='utf-8') as f:
                plan_def = json.load(f)

            # Basic structure validation
            if "plan_meta" not in plan_def:
                return False, "Missing 'plan_meta' section"
            if "reading_order" not in plan_def:
                return False, "Missing 'reading_order' section"

            return True, None
        except json.JSONDecodeError as e:
            return False, f"Invalid JSON: {e}"
        except IOError as e:
            return False, f"Cannot read file: {e}"
```

---

## CLI Integration

### Updated CLI Command

```python
# cli.py

@click.option(
    "--plan",
    type=str,
    default="canonical",
    help="Reading plan to use. Options: 'canonical', plan name, or path to custom plan JSON file"
)
def generate(
    # ... existing params ...
    plan: str,
) -> None:
    """Generate a Bible reading plan."""

    # ... existing code ...

    # Determine which plan strategy to use
    plan_manager = PlanManager(Path("data/reading_plans"))

    if plan == "canonical":
        # Use existing canonical plan
        strategy = CanonicalPlan(bible_data)
    else:
        # Try to find custom plan
        plan_file = plan_manager.get_plan_file(plan)

        if not plan_file:
            raise click.ClickException(
                f"Plan not found: {plan}\n"
                f"Available plans: {', '.join(p['plan_id'] for p in plan_manager.list_available_plans())}"
            )

        # Validate plan file
        is_valid, error_msg = plan_manager.validate_plan_file(plan_file)
        if not is_valid:
            raise click.ClickException(f"Invalid plan file: {error_msg}")

        # Load custom plan
        strategy = CustomPlan(bible_data, plan_file)

        # Display plan info
        plan_meta = strategy.get_plan_metadata()
        click.echo(f"âœ… Loaded plan: {plan_meta['name']}")
        if "description" in plan_meta:
            click.echo(f"   {plan_meta['description']}")

    # ... rest of generation logic ...
```

### List Plans Command

```python
@cli.command()
def list_plans():
    """List all available reading plans."""
    plan_manager = PlanManager(Path("data/reading_plans"))
    plans = plan_manager.list_available_plans()

    if not plans:
        click.echo("No reading plans found.")
        return

    click.echo("\nðŸ“– Available Reading Plans:\n")
    for plan in plans:
        click.echo(f"  â€¢ {plan['name']}")
        click.echo(f"    ID: {plan['plan_id']}")
        click.echo(f"    Strategy: {plan['strategy']}")
        click.echo(f"    Scope: {plan['scope']}")
        if "description" in plan:
            click.echo(f"    Description: {plan['description']}")
        click.echo()
```

---

## Usage Examples

### Example 1: Use Built-in Chronological Plan

```bash
bible-study-planner generate \
  --start-date 2025-01-01 \
  --plan chronological
```

### Example 2: Use Custom Thematic Plan

```bash
bible-study-planner generate \
  --start-date 2025-03-01 \
  --plan wisdom-60
```

### Example 3: Use Plan from Custom Path

```bash
bible-study-planner generate \
  --start-date 2025-06-01 \
  --plan ~/my-plans/church-sermon-series.json
```

### Example 4: List Available Plans

```bash
bible-study-planner list-plans
```

Output:
```
ðŸ“– Available Reading Plans:

  â€¢ Canonical Bible Reading
    ID: canonical
    Strategy: canonical
    Scope: complete

  â€¢ Chronological Bible Reading Plan
    ID: chronological-365
    Strategy: chronological
    Scope: complete
    Description: Read the Bible in the order events occurred

  â€¢ Wisdom Literature in 60 Days
    ID: wisdom-60
    Strategy: thematic
    Scope: old_testament
    Description: Deep dive into Job, Psalms, Proverbs, Ecclesiastes, Song of Solomon
```

---

## Frontmatter Enhancements

### Enhanced Metadata for Custom Plans

Generated daily notes will include additional metadata for custom plans:

```yaml
---
date: 2025-01-15
day: 15
plan_id: chronological-365
plan_name: "Chronological Bible Reading Plan"
plan_strategy: chronological
theme: "Parallel Readings: Kings and Chronicles"
note: "Historical context for divided kingdom"
tags: [bible-study, daily, chronological, old-testament]
testament: old
genre: history
books: [1 Kings, 2 Chronicles]
chapters:
  - book: 1 Kings
    range: "12"
  - book: 2 Chronicles
    range: "10-11"
estimated_minutes: 18
verse_count: 95
word_count: 2850
status: pending
---
```

**New Fields**:
- `plan_strategy`: Type of plan (chronological, thematic, custom)
- `theme`: Optional thematic grouping for the day
- `note`: Optional contextual note for the reading

---

## Implementation Plan

### Phase 1: Core Custom Plan Support (v1.5)

**Week 1-2: Foundation**
- [ ] Create `CustomPlan` class in `bible_study_planner/plans/custom.py`
- [ ] Implement JSON plan loading and validation
- [ ] Add chapter specification parser (ranges, lists, mixed)
- [ ] Create `PlanManager` utility class
- [ ] Unit tests for plan loading and parsing

**Week 3: CLI Integration**
- [ ] Add `--plan` option to generate command
- [ ] Implement plan discovery and selection logic
- [ ] Add `list-plans` command
- [ ] Update help text and documentation
- [ ] Integration tests for CLI

**Week 4: Built-in Plans**
- [ ] Create chronological Bible plan definition
- [ ] Research and implement popular chronological order
- [ ] Validate chronological plan accuracy
- [ ] Create example thematic plans (wisdom, gospels)
- [ ] Documentation for plan format

### Phase 2: Enhanced Features (v1.6) [Future]

**Advanced Plan Features**:
- [ ] Plan templates for quick customization
- [ ] Plan validation tool (CLI command)
- [ ] Plan statistics (total chapters, verses, estimated time)
- [ ] Plan comparison utility
- [ ] Support for reading plan metadata (year of publication, popularity)

**Community Plans**:
- [ ] M'Cheyne reading plan
- [ ] ESV Study Bible plan
- [ ] Blue Letter Bible chronological
- [ ] One Year Bible plan
- [ ] Professor Grant Horner's Bible Reading System

**Plan Generation Tools**:
- [ ] Interactive plan builder CLI
- [ ] Convert existing text plans to JSON
- [ ] Automatic plan distribution (specify books, get balanced plan)
- [ ] Web interface for plan creation (future)

---

## Migration Path

### Backward Compatibility

**Existing behavior preserved**:
```bash
# Still works - uses canonical plan by default
bible-study-planner generate --start-date 2025-01-01
```

**Equivalent with explicit plan**:
```bash
bible-study-planner generate --start-date 2025-01-01 --plan canonical
```

### Canonical Plan as JSON

Convert existing canonical plan logic to JSON definition for consistency:

```json
{
  "plan_meta": {
    "name": "Canonical Bible Reading Plan",
    "plan_id": "canonical",
    "description": "Read the Bible in traditional book order from Genesis to Revelation",
    "strategy": "canonical",
    "scope": "complete"
  },
  "reading_order": "auto-generated"
}
```

Note: For canonical plan, `reading_order` can use special `"auto-generated"` value to trigger existing algorithmic distribution.

---

## Consequences

### Positive

1. **Flexibility**: Users can follow any reading plan without code changes
2. **Chronological Support**: Enables historically-ordered Bible reading
3. **Thematic Studies**: Supports topical and thematic reading plans
4. **Community Sharing**: Users can share plan JSON files
5. **Popular Plans**: Can implement well-known published plans
6. **Extensibility**: Easy to add new plan types
7. **Validation**: Plan structure validated before use
8. **Metadata Rich**: Plans include descriptive metadata
9. **No Breaking Changes**: Fully backward compatible
10. **Separation of Concerns**: Plan definition separate from execution

### Negative

1. **Complexity**: Additional code for plan parsing and validation
2. **User Learning Curve**: Users must understand JSON format
3. **Plan Creation Effort**: Creating custom plans requires manual work
4. **Validation Burden**: Need comprehensive validation to prevent errors
5. **Maintenance**: Built-in plans need ongoing accuracy validation
6. **File Management**: Users must organize plan files

### Neutral

1. **JSON Dependency**: Standard library, but adds parsing layer
2. **Plan Distribution**: Users responsible for finding/creating plans
3. **Documentation Needs**: Requires detailed plan format documentation

---

## Risks & Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| Invalid plan definitions | High | Comprehensive validation with clear error messages |
| Book name mismatches | Medium | Validate all book names against Bible data |
| Chapter number errors | High | Validate chapter ranges against book metadata |
| Complex chapter specs | Medium | Thorough testing of parser with edge cases |
| Plan file not found | Low | Clear error messages, `list-plans` command |
| Scope mismatches | Medium | Validate plan scope against requested scope |
| Performance with large plans | Low | Plans are small JSON files, fast parsing |
| Plan version conflicts | Low | Include version field, deprecation strategy |

---

## Testing Strategy

### Unit Tests

1. **Plan Loading**:
   - Load valid plan JSON
   - Reject invalid JSON
   - Handle missing files
   - Validate required fields

2. **Chapter Parsing**:
   - Single chapter: "5"
   - Chapter range: "1-10"
   - Chapter list: "1,5,10"
   - Mixed: "1-3,5,7-9"
   - Invalid ranges
   - Out of bounds chapters

3. **Plan Validation**:
   - Valid plan structure
   - Missing required fields
   - Invalid scope
   - Invalid strategy
   - Unknown book names
   - Invalid chapter references

4. **Segment Creation**:
   - Single segment days
   - Multiple segment days
   - Parallel readings
   - Statistics calculation

### Integration Tests

1. **Full Plan Generation**:
   - Generate chronological plan (365 days)
   - Generate thematic plan (60 days)
   - Generate custom plan
   - Verify all days created
   - Check metadata correctness

2. **CLI Integration**:
   - `--plan canonical`
   - `--plan chronological`
   - `--plan path/to/plan.json`
   - `--plan nonexistent` (error case)
   - `list-plans` command

3. **Plan Manager**:
   - Discover plans in directory
   - Find plan by ID
   - Find plan by name
   - Validate plan files

### Test Fixtures

Create test plan files:
```
tests/fixtures/plans/
  â”œâ”€â”€ valid-chronological.json
  â”œâ”€â”€ valid-thematic.json
  â”œâ”€â”€ invalid-missing-meta.json
  â”œâ”€â”€ invalid-bad-book.json
  â””â”€â”€ invalid-bad-chapters.json
```

---

## Documentation Updates

### README.md

Add section:
```markdown
### Custom Reading Plans

The Bible study planner supports custom reading plans including chronological and thematic approaches.

**Use a built-in plan**:
bash
bible-study-planner generate --plan chronological


**List available plans**:
bash
bible-study-planner list-plans


**Use a custom plan**:
bash
bible-study-planner generate --plan ~/my-plan.json


#### Available Built-in Plans

- **canonical**: Traditional book order (Genesis to Revelation)
- **chronological**: Historical order of events
- **wisdom-60**: Wisdom literature in 60 days
- **gospels-harmony**: Four Gospels in parallel

#### Creating Custom Plans

Create a JSON file defining your reading order:

json
{
  "plan_meta": {
    "name": "My Custom Plan",
    "plan_id": "my-plan",
    "strategy": "custom",
    "scope": "new_testament"
  },
  "reading_order": [
    {
      "day": 1,
      "segments": [
        {"book": "John", "chapters": "1"}
      ]
    }
  ]
}


See [docs/custom-plans.md](docs/custom-plans.md) for full format specification.
```

### New Documentation File

Create `docs/custom-plans.md` with:
- Complete JSON schema reference
- Field descriptions
- Multiple examples
- Common patterns
- Troubleshooting guide
- Plan creation tutorial

---

## Success Metrics

1. **Functionality**: All built-in plans generate successfully
2. **Accuracy**: Chronological plan matches established orders
3. **Validation**: Clear errors for all invalid plan structures
4. **Performance**: Plan loading adds <100ms to generation time
5. **Usability**: Users can create custom plans without assistance
6. **Adoption**: Positive feedback from users wanting custom plans
7. **Community**: Users share custom plans on GitHub

---

## Future Enhancements

### Phase 3: Advanced Features (v2.0+)

1. **Plan Builder Tool**:
   - Interactive CLI for creating plans
   - Guided plan creation wizard
   - Template-based plan generation

2. **Plan Marketplace**:
   - Community plan repository
   - Plan rating and reviews
   - Plan import from URL

3. **Dynamic Plans**:
   - Conditional logic (skip on Sundays, etc.)
   - Adaptive pacing (adjust based on progress)
   - Multi-track plans (multiple parallel tracks)

4. **Advanced Scheduling**:
   - Skip specific dates
   - Repeat sections
   - Catch-up logic for missed days

5. **Plan Analytics**:
   - Visual plan comparison
   - Coverage maps (which books, when)
   - Difficulty/load balancing metrics

---

## References

- [Bible Reading Plans - BibleGateway](https://www.biblegateway.com/reading-plans/)
- [Chronological Bible Reading Plan - Blue Letter Bible](https://www.blueletterbible.org/study/paul/chrono.cfm)
- [Robert M'Cheyne's Calendar](https://www.esv.org/resources/reading-plans/mcheyne/)
- [The One Year Bible](https://www.tyndale.com/oneyearbible)
- [Professor Grant Horner's Bible Reading System](http://www.professorgrant.com/10Lists.pdf)
- [JSON Schema Specification](https://json-schema.org/)

---

## Approval

- [ ] Feature Specification Approved
- [ ] Implementation Plan Approved
- [ ] JSON Schema Approved
- [ ] Testing Strategy Approved
- [ ] Documentation Plan Approved
- [ ] Ready for Development

**Approved By**: _________________
**Date**: _________________

---

## Changelog

| Date | Version | Changes | Author |
|------|---------|---------|--------|
| 2025-12-28 | 1.0 | Initial ADR for custom plan capability | Development Team |
